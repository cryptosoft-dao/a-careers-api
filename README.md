Some DAO Backend
================

Бэкенд для web3-системы на базе блокчейна TON. Хранит информацию об NFT-айтемах коллекции в локальной БД, предоставляет возможность поиска по базе для фронтенда. Оперативно обновляет информацию в БД при изменении данных в блокчейне.


Требования к смартконтрактам
----------------------------

* Айтемы должны принадлежать строго одной коллекции (адрес коллекции задается в настройках);
* Коллекция должна поддерживать методы `get_collection_data` и `get_nft_address_by_index` из стандарта [TEP-62](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md);
* Индексация (нумерация) айтемов в коллекции должна быть последовательная;
* Айтемы должны поддерживать методы `get_nft_data` и `get_nft_content` из TEP-62;
* Айтемы должны возвращать результат `get_nft_content` вида **On-chain content layout** согласно [TEP-64](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md)
    * Поддерживаются следующие поля метаданных:
        * `image`, `name`, `description`, `status`, `technical_assigment`, `category`, `customer_addr` - строковые, хранятся в формате **Snake format**; 
        * `amount` - целое число, хранится как строка в формате **Snake format**; 
        * `starting_unix_time`, `ending_unix_time`, `creation_unix_time` - целое число обозначающее Unix file time seconds, хранится как строка в формате **Snake format**; 
* Изменение данных в айтемах должно сопровождаться транзакцией на фиксированном адресе (адрес прослушивается, появление транзакций будет инициировать обновление соотв. айтемов);

Процедура обновления данных
---------------------------

Используется одновременно несколько способов получения событий об айтемах:

1. Периодический (параметр `NewOrdersDetectorInterval`, по умолчанию 15 мин) вызов метода коллекции `get_collection_data` для получения информации о новых сминченных айтемах (путем проверки next item index). 
2. Периодический (параметр `CollectionTxTrackingInterval`, по умолчанию 30 секунд) просмотр новых транзакций на смартконтракте коллекции: 
      * при обнаружении транзакций на новые (неизвестные) адреса вне очереди запускается метод (1) для проверки новых сминченных айтемов;
      * при обнаружении транзакций на известные адреса (айтемов) запускается задача по их обновлению;
3. Периодический (параметр `MasterTxTrackingInterval`, по умолчанию 10 секунд) просмотр новых транзакций на фиксированном мастер-адресе: 
      * при обнаружении транзакций на известные адреса (айтемов) запускается задача по их обновлению;


Настройки системы
-----------------

Для настройки используется файл `appsettings.json` в корне приложения. Каждая настройка имеет описание прямо внутри файла.

**После изменения** файла настроек необходимо **перезапустить** приложение, чтобы измененный файл считался.

Самыми главнымм являются параметры:
  * `CollectionAddress` - адрес самой коллекции;
  * `MasterAddress` - адрес мастер-контракта, через который проходят изменения в айтемах;

⚠ Важно! Если меняется **адрес коллекции**, то помимо перезапуска необходимо **удалить файл базы данных** (`backend.sqlite`), чтобы стереть старые (неактуальные) айтемы!

ℹ Для облегчения последующих обновлений системы можно не менять исходный файл `appsettings.json`, а сделать рядом новый с именем `appsettings.Production.json` и скопировать туда только параметры с изменяемыми значениями (важно следить за вложенностью Json-структур!). Система будет считывать оба файла при старте, и возьмет сначала значения по умолчанию из исновного файла, а потом обновит необходимые значения считанными из второго файла.


Требования к серверу, развертывание и запуск системы
----------------------

Требования к серверу:

* Для работы необходим [**Microsoft .NET 6.0**](https://dotnet.microsoft.com/en-us/download/dotnet/6.0), который работает на Linux, Windows и macOS.
* [NGINX](https://nginx.org/) рекомендуется в качестве реверс-прокси и для управления SSL сертификатом (например бесплатный  от Let's Encrypt через [certbot](https://certbot.eff.org/));
* В качестве базы данных используется **SQLite**, который не требует какой-либо предварительной установки.

Порядок установки описан в файле [Deployment.md](Deployment.md). 